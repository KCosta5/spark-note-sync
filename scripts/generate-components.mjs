import { readdir, stat, writeFile } from 'fs/promises';
import path from 'path';

const root = path.resolve('./');
const componentsDir = path.join(root, 'src', 'components');
const outFile = path.join(root, 'src', 'lib', 'componentsList.ts');

async function walk(dir) {
  const entries = await readdir(dir, { withFileTypes: true });
  const files = [];
  for (const ent of entries) {
    const full = path.join(dir, ent.name);
    if (ent.isDirectory()) {
      files.push(...(await walk(full)));
    } else {
      files.push(full);
    }
  }
  return files;
}

function normalizeName(filePath) {
  const parts = filePath.split(path.sep);
  // get last part without extension
  const file = parts[parts.length - 1];
  const name = file.replace(/\.(tsx|ts|jsx|js)$/i, '');
  return name;
}

async function main() {
  const allFiles = await walk(componentsDir);
  const candidates = allFiles.filter((f) => /\.(tsx|ts|jsx|js)$/.test(f));

  const uiPrefix = path.join('src', 'components', 'ui') + path.sep;

  const list = [];
  for (const f of candidates) {
    // only include files inside src/components or src/components/ui
    const rel = path.relative(root, f).replaceAll('\\', '/');
    if (!rel.startsWith('src/components/')) continue;
    // ignore storybook, test, index files
    const base = normalizeName(f);
    if (/^(index|types|constants|helpers?)$/i.test(base)) continue;
    // create readable name from filename
    list.push(base);
  }

  // dedupe and sort
  const uniq = Array.from(new Set(list)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

  const ts = `// Auto-generated by scripts/generate-components.mjs
// Do not edit by hand â€” run ` + "npm run generate:components" + ` to refresh
const COMPONENTS = ${JSON.stringify(uniq, null, 2)} as const;

export default COMPONENTS as readonly string[];
`;

  await writeFile(outFile, ts, 'utf8');
  console.log('Wrote', outFile, 'with', uniq.length, 'components');
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
